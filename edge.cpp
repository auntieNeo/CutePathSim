#include <QBrush>
#include <QGraphicsScene>
#include <QPen>
#include <QDebug>
#include <cmath>
#include <QtGlobal>

#include "common.h"
#include "edge.h"

#define EDGE_ANIMATION_LENGTH 50

#include <iostream>
using namespace std;

namespace CutePathSim
{
  /**
   * \class
   * The Edge class represents an edge in the component graph. It draws the curve that was generated by Graphviz between nodes on the graph, along with labels and arrows. It also recieves various mouse events to allow the user to interact with the edge.
   */
  /**
   * Constructs an edge with \a from as the sending output and \a input as the receving input, and \a parent as the parent.
   */
  Edge::Edge(Component::Output *from, Component::Input *to, QGraphicsItem *parent) : QGraphicsItem(parent)
  {
    m_from = from;
    m_to = to;
    m_drawHover = false;
    m_path = new Path(this);
    m_arrow = new Arrow(this);
    setZValue(EDGE_Z_VALUE);
    m_animationStep = .5;
  }

  Edge::~Edge()
  {
    delete m_path;
  }

  /**
   * Sets the path used to draw the edge to \a path.
   */
  void Edge::setPath(const QPainterPath &path)
  {
    prepareGeometryChange();
    m_path->setPath(path);;

    // make the arrow
    QPainterPath arrowPath;
    arrowPath.moveTo(path.currentPosition());
    arrowPath.lineTo(path.currentPosition() + QPointF(-15, -5));
    arrowPath.lineTo(path.currentPosition() + QPointF(-15, 5));
    arrowPath.lineTo(path.currentPosition());
    m_arrow->setPath(arrowPath);
    m_arrow->setTransformOriginPoint(path.currentPosition());
    m_arrow->setRotation(-path.angleAtPercent(1));

    update();
  }

  QRectF Edge::boundingRect() const
  {
    QRectF result;
    foreach(QGraphicsItem *child, childItems())
    {
      result |= child->boundingRect();
    }
    return result;
  }

  void Edge::Path::paint(QPainter *painter, const QStyleOptionGraphicsItem *style, QWidget *widget)
  {
    this->QGraphicsPathItem::paint(painter, style, widget);
    if(m_edge->m_animationStep != -1)
    {
      qreal step = m_edge->m_animationStep;
      QPen oldPen = pen();

      qreal lengthRatio = EDGE_ANIMATION_LENGTH / path().length();
      QLinearGradient gradient;
      gradient.setColorAt(0, Qt::transparent);
      gradient.setColorAt(qMax(step - lengthRatio, qreal(0)), Qt::transparent);
      gradient.setColorAt(qMin(step + lengthRatio, 0.999), Qt::green);
      gradient.setColorAt(qMin(step + lengthRatio + 0.0001, qreal(1)), Qt::transparent);
      setPen(QPen(QBrush(gradient), 4));
      QGraphicsPathItem::paint(painter, style, widget);
      setPen(oldPen);
    }
  }

  Edge::Path::Path(Edge *parent) : QGraphicsPathItem(parent)
  {
    m_edge = parent;
    setPen(QPen(QBrush(Qt::SolidPattern), 2));
    setAcceptHoverEvents(true);
  }

  Edge::Path::~Path()
  {
  }

  void Edge::Path::hoverEnterEvent(QGraphicsSceneHoverEvent *)
  {
    setPen(QPen(QBrush(Qt::SolidPattern), 4));
    update();
    // FIXME: make a hover threashold so that it doesn't blink as much
  }

  void Edge::Path::hoverLeaveEvent(QGraphicsSceneHoverEvent *)
  {
    setPen(QPen(QBrush(Qt::SolidPattern), 2));
    update();
  }

  Edge::Arrow::Arrow(Edge *parent) : QGraphicsPathItem(parent)
  {
    m_edge = parent;
    setBrush(QBrush(Qt::SolidPattern));
    setAcceptHoverEvents(true);
  }

  Edge::Arrow::~Arrow()
  {
  }

  void Edge::Arrow::hoverEnterEvent(QGraphicsSceneHoverEvent *)
  {
    // TODO: add something for the arrow hover
    update();
    // FIXME: make a hover threashold so that it doesn't blink as much
  }

  void Edge::Arrow::hoverLeaveEvent(QGraphicsSceneHoverEvent *)
  {
    update();
  }
}
